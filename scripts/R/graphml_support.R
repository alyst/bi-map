# Exporting graphs defined by nodes & edges table into GraphML
# 
# Author: astukalov
###############################################################################

require( XML )
require( plyr )

generateGraphML <- function(
    nodes, edges,
    node_col = 'node', parent_col = 'parent',
    source_col = 'source', target_col = 'target',
    node_attrs_export_names = NULL,
    edge_attrs_export_names = NULL,
    directed = TRUE
){
    graphMLRoot <- newXMLNode( "graphml", namespace = "", 
        namespaceDefinitions=c("http://graphml.graphdrawing.org/xmlns",
            xsi="http://www.w3.org/2001/XMLSchema-instance",
            y="http://www.yworks.com/xml/graphml",
            yed="http://www.yworks.com/xml/yed/3"
        ),
        attrs = c( "xsi:schemaLocation"="http://graphml.graphdrawing.org/xmlns
http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd" )
    )

    newXMLCommentNode( 'Generated by R, Alexey Stukalov @ CeMM', parent = graphMLRoot )

    # mapping of attributes from R to GraphML
    attrClassMap <- c( 'character' = 'string',
                       'numeric' = 'double', 'integer' = 'int',
                       'logical' = 'boolean' )
    
    writeAttrNodes <- function( attrOf, df, attrCols, attrNames ) {
        attrs.df <- data.frame(
            name = attrCols,
            export_name = attrCols,
            id = paste( substr( attrOf, 1, 1 ), 1:length( attrCols ), sep = '' ),
            type = sapply( attrCols, function( attr ) attrClassMap[ as.character( class( df[, attr] ) ) ] ),
            stringsAsFactors = FALSE
        )
        rownames( attrs.df ) <- attrCols
        # substitute the column name with the export name of the attribute
        if ( !is.null( attrNames ) ) {
            attrs.df[ attrs.df$name %in% names( attrNames ), 'export_name' ] <- 
                    attrNames[ attrs.df[ attrs.df$name %in% names( attrNames ), 'export_name' ] ]
        }
        attrKeyNodes <- apply( attrs.df, 1, function( attr ) {
                newXMLNode( 'key', parent = graphMLRoot, attrs = list(
                        'for'= attrOf,
                        'id' = attr['id'],
                        'attr.name' = attr['export_name'],
                        'attr.type' = attr['type'] ) )
            } )
        return ( attrs.df )
    }
    # generate node attributes
    message( 'Generating node attributes...' )
    newXMLCommentNode( 'Node attributes definitions', parent = graphMLRoot )
    nodeAttrs.df <- writeAttrNodes( 'node', nodes, setdiff( colnames( nodes ), c( source_col, target_col ) ), node_attrs_export_names )
    print( nodeAttrs.df )
    message( 'Generating edge attributes...' )
    newXMLCommentNode( 'Edge attributes definitions', parent = graphMLRoot )
    if ( nrow(edges) > 0 ) {
        edgeAttrs.df <- writeAttrNodes( 'edge', edges, setdiff( colnames( edges ), c( source_col, target_col ) ), edge_attrs_export_names )
        print( edgeAttrs.df )
    } else {
        warning( 'No edges' )
    }
    
    message( 'Generating nodes...' )
    writeDataNode <- function( attr, data, parentNode ) {
        attr_val = data[ attr['name'] ]
        if ( length( attr_val ) > 1 ) {
            warning( 'Multiple data rows provided' )
        }
        if ( !is.na( attr_val ) ) {
            if ( attr[ 'type' ] == 'boolean' ) {
                attr_val = ifelse( attr_val == 'FALSE', 'false', 'true' )
            }
            newXMLNode( 'data', attr_val, 
                parent = parentNode,
                attrs = list( key = attr[ 'id' ] ) )
        }
    }
    writeNodeSet <- function( graph_node_ids, parent_xml_node ) {
        lapply( graph_node_ids, function( node_id ) {
                nodeXmlNode <- newXMLNode( 'node', parent = parent_xml_node, attrs = list( id = node_id ) )
                node_data <- nodes[ nodes[,node_col] == node_id, ]
                if ( nrow( node_data ) > 1 ) {
                    stop( 'Duplicate node id: ', node_id )
                }
                apply( nodeAttrs.df, 1, writeDataNode, node_data, nodeXmlNode )
                # write subgraph
                if ( !is.null( parent_col ) ) {
                    children_mask <- !is.na(nodes[,parent_col]) & (nodes[,parent_col] == node_id)
                    if ( sum( children_mask ) > 0 ) {
                        message('Writing subgraph of node \"', node_id, '\"...' )
                        addAttributes( nodeXmlNode, "yfiles.foldertype" = "group" )
                        subnodes <- nodes[ children_mask, node_col ]
                        if ( node_id %in% subnodes ) {
                            stop( '\"', node_id, '\" is child of itself, stopping to avoid recursion')
                        }
                        subgraphXmlNode <- newXMLNode( 'graph', parent = nodeXmlNode,
                                                       attrs = list( id = paste( node_id, '_subgraph', sep = '' ),
                                                           edgedefault = ifelse( directed, 'directed', 'undirected' ) ) )
                        newXMLCommentNode( paste('Subgraph of node', node_id ), parent = subgraphXmlNode )
                        writeNodeSet( subnodes, subgraphXmlNode )
                    }
                }
                nodeXmlNode
            } )
    }

    if ( !is.null( parent_col ) ) {
        rootNodes <- nodes[ is.na(nodes[, parent_col ]), node_col ]
    } else {
        rootNodes <- nodes[ , node_col ]
    }
    newXMLCommentNode( 'Graph', parent = graphMLRoot )
    rootGraph <- newXMLNode( 'graph', parent = graphMLRoot,
                              attrs = list( id = 'root', 
                                  edgedefault = ifelse( directed, 'directed', 'undirected' ) ) )
    newXMLCommentNode( 'Nodes', parent = rootGraph )
    writeNodeSet( rootNodes, rootGraph )

    if ( !is.null(edges) && nrow( edges ) > 0 ) {
        message( 'Generating edges...' )
        newXMLCommentNode( 'Edges', parent = rootGraph )
        ddply( edges, c( source_col, target_col ), function( edge_data ) {
                sourceNode <- edge_data[ , source_col ]
                targetNode <- edge_data[ , target_col ]
                edgeXmlNode <- newXMLNode( 'edge', parent = rootGraph, 
                    attrs = list( id = paste( sourceNode, targetNode, sep = '_' ), 
                        source = sourceNode, target = targetNode ) )
                apply( edgeAttrs.df, 1, writeDataNode, edge_data, edgeXmlNode )
                edgeXmlNode
                return ( NULL )
            } )
    }

    graphMLDoc <- newXMLDoc( node = graphMLRoot, addFinalizer = TRUE )
}

#example <- list(
#    nodes = data.frame( node = c( 'A', 'B', 'C', 'D' ),
#                        parent = c( NA, NA, 'A', 'A' ),
#                        color = c( 'red', 'red', 'blue', 'green' ),
#                        size = c( 2, 3.5, 4, 1.5 ),
#                        stringsAsFactors = FALSE ),
#    edges = data.frame( source = c( 'A', 'B', 'C', 'D' ),
#                        target = c( 'B', 'C', 'D', 'B' ),
#                        color = c( 'yellow', 'blue', 'blue', 'white' ),
#                        virtual = c( FALSE, TRUE, TRUE, FALSE ),
#                        multiple = c( 2, 4, 5, 3 ),
#                        stringsAsFactors = FALSE )
#                )
#
#example$graphml <- generateGraphML( example$nodes, example$edges )
#saveXML( example$graphml, file = '~/exampleR.graphml' )

#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_math.h>

#include "logmath.h"

#include "GenericDiscreteDistribution.h"

#include "PitmanYorProcess.h"

PitmanYorProcess::PitmanYorProcess(
    prob_t  concentration,
    prob_t  discount
) : concentration( concentration )
  , discount( discount )
{
    /// @fixme it's also possible, that discount = -k, concentration = -m k
    if ( discount >= 1 || discount < 0 ) THROW_EXCEPTION( std::invalid_argument, "discount not in [0,1): " << discount );
    if ( concentration < -discount ) THROW_EXCEPTION( std::invalid_argument, "concentration < -discount: " << concentration );
}

/**
    Generate random distribution of N samples.
    Distibution is generated by modelling Chinese restraunt process.
 */
PitmanYorSample PitmanYorProcess::random(
    const gsl_rng*                  r,
    PitmanYorProcess::size_type     samplesCount
) const {
    PitmanYorSample     res;

    probability_vector_t    tableProb;
    tableProb.reserve( samplesCount / 8 );

    tableProb.push_back( concentration );

    for ( size_t i = 0; i < samplesCount; i++ ) {
        GenericDiscreteDistribution prob( tableProb );
        size_type tableIx = prob.random( r );
        if ( tableIx == tableProb.size() - 1 ) {
            // occupy empty table
            tableProb.back() = 1 - discount;   // just occupied table probability
            tableProb.push_back( concentration + discount * tableProb.size() ); // next new table probability
        }
        else {
            // seat at occupied table
            tableProb[ tableIx ] += 1.0;  // update probability of chosen table
        }
        res.push_next_sample( tableIx );
    }
    return ( res );
}

/**
    @see PRIOR DISTRIBUTIONS FOR PARTITIONS IN BAYESIAN NONPARAMETRICS, LEE DICKER and SHANE T. JENSEN
 */
prob_t PitmanYorProcess::expectedClustersCount( const size_type samplesCount ) const
{
    if ( samplesCount == 0 ) return ( 0 );
    else if ( samplesCount == 1 ) return ( 1 );
    else if ( discount > 0 ) {
        return ( ( gsl_sf_poch( concentration + samplesCount, discount ) 
                 * gsl_sf_poch( concentration + discount, 1 - discount ) - concentration ) / discount );
        #if 0
        double res = ( concentration + discount );
        for ( size_t i = 1; i < samplesCount; i++ ) {
            res *= ( 1.0 + discount / ( i + concentration ) );
        }
        return ( ( res - concentration ) / discount );
        #endif
    }
    else {
        prob_t res = 0;
        for ( size_t i = 0; i < samplesCount; i++ ) {
            res += 1.0 / ( i + concentration );
        }
        return ( concentration * res );
    }
}

PitmanYorProcess::weight_vector_type PitmanYorProcess::sampleLogStickBreaks(
    const gsl_rng*          r,
    const size_vector_type& groupSizes,
    int                     curClusterIx,
    int                     newClusterIx
) const {
    weight_vector_type  res( groupSizes.size() );
    std::size_t         sizesSum = 0;
    for ( int i = (int)groupSizes.size() - 1; i >= 0; i-- ) {
        size_type  groupSize = groupSizes[ i ];
        if ( i == curClusterIx )  groupSize--;
        else if ( i == newClusterIx ) groupSize++;

        res[ i ] = gsl_ran_beta( r, 1 - discount + groupSize, concentration + i * discount + sizesSum );
        sizesSum += groupSize;
    }
    return ( res );
}

PitmanYorProcess::weight_vector_type PitmanYorProcess::sampleLogWeights(
    const gsl_rng*          r,
    const size_vector_type& groupSizes,
    int                     curClusterIx,
    int                     newClusterIx
) const {
    weight_vector_type  v = sampleLogStickBreaks( r, groupSizes, curClusterIx, newClusterIx );
    weight_vector_type  res( v.size(), 0 );

    res[0] = 0;
    for ( size_t i = 1; i < res.size(); i++ ) {
        res[i] = res[i-1] + fast_log1p( -v[i-1] );
    }
    for ( size_t i = 0; i < res.size(); i++ ) {
        res[i] += __builtin_log( v[i] );
    }
    return ( res ); 
}

/**
    Probability to assign element to the cluster.
 */
prob_t PitmanYorProcess::clusterAssignmentPrior(
    size_type   clusterSize,        /** cluster size, if 0 -- new cluster */
    size_type   clustersCount,      /** number of clusters */
    size_type   elementsCount       /** number of elements, excluding new element */
) const {
    prob_t  denom = ( elementsCount + concentration );
    return ( ( clusterSize == 0 ? concentration + discount * clustersCount
                                : clusterSize - discount ) / denom );
}

void PitmanYorSample::push_next_sample(
    cluster_index_type clusterIx
){
    BOOST_ASSERT( clusterIx <= _clusterToSamples.size() );
    sample_index_type   sampleIx = samplesCount();
    _sampleToCluster.push_back( clusterIx );
    if ( clusterIx == _clusterToSamples.size() ) {
        _clusterToSamples.push_back( sample_set_type() );
    }
    _clusterToSamples[ clusterIx ].insert( sampleIx );
}

PitmanYorProcess::PYLnPAccum::PYLnPAccum(
    const PitmanYorProcess& py
) : PriorLnPAccumBase( py )
{
    BOOST_ASSERT( py.discount > 0 );
}

PitmanYorProcess::PYLnPAccum& PitmanYorProcess::PYLnPAccum::operator<<(
    size_t groupSize
){
    BOOST_ASSERT( groupSize > 0 );
    accum += PitmanYorProcess::lnPoch( py.__lnPoch_discount_cache,
                                       1 - py.discount, groupSize - 1 );
    PriorLnPAccumBase::operator<<( groupSize );
    return ( *this );
}

log_prob_t PitmanYorProcess::PYLnPAccum::operator()() const
{
    return ( accum
             // ( conc/disc + 1 ) * (conc/disc + 2 ) * ... * ( conc/disc + n - 1 ) * disc^{n-1}
             + gsl_sf_lnpoch( 1.0 + py.concentration / py.discount, groupsCount - 1 )
             + ( groupsCount - 1 ) * log( py.discount )
             - PitmanYorProcess::lnPoch( py.__lnPoch_concentration_cache,
                                         1 + py.concentration, samplesCount - 1 ) );
}

/** see 2.19 */
PitmanYorProcess::DirichletLnPAccum::DirichletLnPAccum(
    const PitmanYorProcess& py
) : PriorLnPAccumBase( py )
{
    BOOST_ASSERT( py.discount == 0 );
}

PitmanYorProcess::DirichletLnPAccum& PitmanYorProcess::DirichletLnPAccum::operator<<(
    size_t groupSize
){
    BOOST_ASSERT( groupSize > 0 );
    accum += ln_factorial( groupSize - 1 );
    PriorLnPAccumBase::operator<<( groupSize );
    return ( *this );
}

log_prob_t PitmanYorProcess::DirichletLnPAccum::operator()() const
{
    return ( accum + groupsCount * __builtin_log( py.concentration ) +
             - PitmanYorProcess::lnPoch( py.__lnPoch_concentration_cache,
                                         py.concentration, samplesCount ) );
}
